% -------------- 2.12 Example Job Script: Fluent --------------
% -------------------------------------------------------------
\subsection{Example Job Script: Fluent}

\begin{figure}[htpb]
  \lstinputlisting[language=csh,frame=single,basicstyle=\footnotesize\ttfamily]{fluent.sh}
  \caption{Source code for \file{fluent.sh}}
  \label{fig:fluent.sh}
\end{figure}

The job script in \xf{fig:fluent.sh} runs Fluent in parallel over 32 cores. 
%Of note, we have requested e-mail notifications (\texttt{-m}), are defining the 
Notable aspects of this script include requesting e-mail notifications (\texttt{--mail-type}), 
defining the parallel environment for Fluent with \texttt{-t\$SLURM\_NTASKS} and \texttt{-g-cnf=\$FLUENTNODES}, 
%parallel environment for, \tool{fluent}, with, \texttt{-sgepe smp} (\textbf{very 
and setting \api{\$TMPDIR} as the in-job location for the ``moment'' \file{rfile.out} file.
The script also copies everything from \api{\$TMPDIR} to a directory in the user's NFS-mounted home after the job completes.
Job progress can be monitored by examining the standard-out file (e.g.,
%\file{flu10000.o249}), and/or by examining the ``moment'' file in 
\texttt{slurm-249.out}), and/or by examining the ``moment'' file in 
\texttt{/disk/nobackup/<yourjob>} (it starts with your job-ID) on the node running
the job. Be cautious with journal-file paths.

% -------------- 2.13 Example Job Script: EfficientDet --------
% -------------------------------------------------------------
\subsection{Example Job: EfficientDet}

The following steps describe how to create an EfficientDet environment on Speed, 
as submitted by a member of Dr. Amerâ€™s research group:

\begin{itemize}
  \item Navigate to your \texttt{speed-scratch} directory:
  \begin{verbatim}
    cd /speed-scratch/$USER
  \end{verbatim}
  \item Load Python module
  \begin{verbatim}
    module load python/3.8.3
  \end{verbatim}
  \item Create and activate the virtual environment
  \begin{verbatim}
    python3 -m venv <env_name>
    source <env_name>/bin/activate.csh
  \end{verbatim}
  \item Install DL packages for EfficientDet
  \small
  \begin{verbatim}
    pip install tensorflow==2.7.0
    pip install lxml>=4.6.1
    pip install absl-py>=0.10.0
    pip install matplotlib>=3.0.3
    pip install numpy>=1.19.4
    pip install Pillow>=6.0.0
    pip install PyYAML>=5.1
    pip install six>=1.15.0
    pip install tensorflow-addons>=0.12
    pip install tensorflow-hub>=0.11
    pip install neural-structured-learning>=1.3.1
    pip install tensorflow-model-optimization>=0.5
    pip install Cython>=0.29.13
    pip install git+https://github.com/cocodataset/cocoapi.git#subdirectory=PythonAPI
    \end{verbatim}
  \normalsize
\end{itemize}

% -------------- 2.14 Java Jobs -------------------------------
% -------------------------------------------------------------
\subsection{Java Jobs}
\label{sect:java}

Jobs that call Java have a memory overhead, which needs to be taken 
%into account when assigning a value to \api{h\_vmem}. Even the most basic 
into account when assigning a value to \option{--mem}. Even the most basic 
Java call, such as \texttt{Java -Xmx1G -version}, will need to have,
%\texttt{-l h\_vmem=5G}, with the 4-GB difference representing the memory overhead. 
\texttt{--mem=5G}, with the 4 GB difference representing the memory overhead. 
\textbf{Note} that this memory overhead grows proportionally with the value of
\texttt{-Xmx}.

For example, 
\begin{itemize}
  \item When \texttt{-Xmx} has a value of 100G, \option{--mem} has to be at least 106G.
  \item For \texttt{-Xmx} of 200G, \option{--mem} has to be at least 211G.
  \item For \texttt{-Xmx} of 300G, \option{--mem} has to be at least 314G.
\end{itemize}

% TODO: add MARF and GIPSY Java jobs

% -------------- 2.15 Scheduling on the GPU Nodes -------------
% -------------------------------------------------------------
\subsection{Scheduling on the GPU Nodes}

The primary cluster has two GPU nodes, each with six Tesla (CUDA-compatible) P6
cards. Each card has 2048 cores and 16GB of RAM. Note that the P6
is mainly a single-precision card, so unless you need GPU double precision, 
double-precision calculations will be faster on a CPU node.

\noindent Job scripts for the GPU queue differ in that they need this statement,
which attaches either a single GPU or two GPUs to the job:
\begin{verbatim}
  #SBATCH --gpus=[1|2]
\end{verbatim}

%do not need these
%statements:
%\begin{verbatim}
%#$ -pe smp <threadcount>
%#$ -l h_vmem=<memory>G
%\end{verbatim}

%\begin{verbatim}
%#$ -l gpu=[1|2]
%\end{verbatim}

% TODO: verify accuracy
% Single-GPU jobs are granted 5~CPU cores and 80GB of system memory, and
% dual-GPU jobs are granted 10~CPU cores and 160GB of system memory. A
% total of \emph{four} GPUs can be actively attached to any one user at any given time.

\noindent Once your job script is ready, submit it to the GPU partition (queue) with:
%\begin{verbatim}
%qsub -q g.q ./<myscript>.sh
%\end{verbatim}
\begin{verbatim}
  sbatch -p pg ./<myscript>.sh
\end{verbatim}

\noindent You can query \tool{nvidia-smi} on the node running your job with:
\begin{verbatim}
  ssh <username>@speed[-05|-17|37-43] nvidia-smi
\end{verbatim}

\noindent The status of the GPU queue can be queried with:
%\begin{verbatim}
%qstat -f -u "*" -q g.q
%\end{verbatim}
\begin{verbatim}
  sinfo -p pg --long --Node
\end{verbatim}

\noindent \textbf{Important note for TensorFlow and PyTorch users:}:
if you are planning to run TensorFlow and/or PyTorch multi-GPU jobs, 
do not use the \api{tf.distribute} and/or \api{torch.nn.DataParallel} functions 
on \textbf{speed-01, speed-05, or speed-17}, as they will crash the compute node (100\% certainty). 
This appears to be a defect in the current hardware architecture.
%
% TODO: Need to link to that example
The workaround is to either manually effect GPU parallelisation
(TensorFlow provides an example on how to do this), or to run on a single GPU.\\

\noindent \textbf{Important}:
%Users without permission to use the GPU nodes can submit jobs to the \texttt{g.q}
Users without permission to use the GPU nodes can submit jobs to the \texttt{pg}
partition, but those jobs will hang and never run.
Their availability can be seen with:
%
%There are two GPUs in both \texttt{speed-05} and \texttt{speed-17}, and one 
%in \texttt{speed-19}.
%, \texttt{qstat -F g} (note the capital): 
%
%\small
%\begin{verbatim}
%queuename                      qtype resv/used/tot. load_avg arch          states
%---------------------------------------------------------------------------------
%...
%---------------------------------------------------------------------------------
%g.q@speed-05.encs.concordia.ca BIP   0/0/32         0.04     lx-amd64
        %hc:gpu=6
%---------------------------------------------------------------------------------
%g.q@speed-17.encs.concordia.ca BIP   0/0/32         0.01     lx-amd64
        %hc:gpu=6
%---------------------------------------------------------------------------------
%...
%---------------------------------------------------------------------------------
%s.q@speed-19.encs.concordia.ca BIP   0/32/32        32.37    lx-amd64
        %hc:gpu=1
%---------------------------------------------------------------------------------
%etc. 
%\end{verbatim}
%\normalsize
\small
\begin{verbatim}
[serguei@speed-submit src] % sinfo -p pg --long --Node
Thu Oct 19 22:31:04 2023
NODELIST   NODES PARTITION       STATE CPUS    S:C:T MEMORY TMP_DISK WEIGHT AVAIL_FE REASON
speed-05       1        pg        idle 32     2:16:1 515490        0      1    gpu16 none
speed-17       1        pg     drained 32     2:16:1 515490        0      1    gpu16 UGE
speed-25       1        pg        idle 32     2:16:1 257458        0      1    gpu32 none
speed-27       1        pg        idle 32     2:16:1 257458        0      1    gpu32 none
[serguei@speed-submit src] % sinfo -p pt --long --Node
Thu Oct 19 22:32:39 2023
NODELIST   NODES PARTITION       STATE CPUS    S:C:T MEMORY TMP_DISK WEIGHT AVAIL_FE REASON
speed-37       1        pt        idle 256    2:64:2 980275        0      1 gpu20,mi none
speed-38       1        pt        idle 256    2:64:2 980275        0      1 gpu20,mi none
speed-39       1        pt        idle 256    2:64:2 980275        0      1 gpu20,mi none
speed-40       1        pt        idle 256    2:64:2 980275        0      1 gpu20,mi none
speed-41       1        pt        idle 256    2:64:2 980275        0      1 gpu20,mi none
speed-42       1        pt        idle 256    2:64:2 980275        0      1 gpu20,mi none
speed-43       1        pt        idle 256    2:64:2 980275        0      1 gpu20,mi none
\end{verbatim}
\normalsize

\noindent To specifically request a GPU node, add, \texttt{--gpus=[\#GPUs]},
%\texttt{-l g=[\#GPUs]}, to your \tool{qsub} (statement/script) or
to your \tool{sbatch} statement/script or \tool{salloc} statement request.
%\tool{qlogin} (statement) request. For example,
For example:
\begin{verbatim}
  sbatch -t 10 --mem=1G --gpus=1 -p pg ./tcsh.sh
\end{verbatim}
%\texttt{qsub -l h\_vmem=1G -l g=1 ./count.sh}.

%\small
%\begin{verbatim}
%queuename                      qtype resv/used/tot. load_avg arch          states
%--------------------------------------------------------------------------------- 
%g.q@speed-05.encs.concordia.ca BIP 0/0/32 0.01 lx-amd64  hc:gpu=6 
%--------------------------------------------------------------------------------- 
%g.q@speed-17.encs.concordia.ca BIP 0/0/32 0.01 lx-amd64  hc:gpu=6 
%--------------------------------------------------------------------------------- 
%s.q@speed-19.encs.concordia.ca BIP 0/1/32 0.04 lx-amd64  hc:gpu=0 (haff=1.000000) 
       %538 100.00000 count.sh   sbunnell     r     03/07/2019 02:39:39     1
%---------------------------------------------------------------------------------
%etc. 
%\end{verbatim}
%\normalsize

%\small
%\begin{verbatim}
%queuename                      qtype resv/used/tot. load_avg arch          states
%--------------------------------------------------------------------------------- 
%g.q@speed-05.encs.concordia.ca BIP 0/0/32 0.01 lx-amd64  hc:gpu=6 
%--------------------------------------------------------------------------------- 
%g.q@speed-17.encs.concordia.ca BIP 0/0/32 0.01 lx-amd64  hc:gpu=6 
%--------------------------------------------------------------------------------- 
%s.q@speed-19.encs.concordia.ca BIP 0/1/32 0.04 lx-amd64  hc:gpu=0 (haff=1.000000) 
       %538 100.00000 count.sh   sbunnell     r     03/07/2019 02:39:39     1
%---------------------------------------------------------------------------------
%etc. 
%\end{verbatim}
%\normalsize

\footnotesize
\begin{verbatim}
[serguei@speed-submit src] % squeue -p pg -o "%15N %.6D %7P %.11T %.4c %.8z %.6m %.8d %.6w %.8f %20G %20E"
NODELIST         NODES PARTITI       STATE MIN_    S:C:T MIN_ME MIN_TMP_  WCKEY FEATURES GROUP DEPENDENCY
speed-05             1 pg          RUNNING    1    *:*:*     1G        0 (null)   (null) 11929     (null)
[serguei@speed-submit src] % sinfo -p pg -o "%15N %.6D %7P %.11T %.4c %.8z %.6m %.8d %.6w %.8f %20G %20E"
NODELIST         NODES PARTITI       STATE CPUS    S:C:T MEMORY TMP_DISK WEIGHT AVAIL_FE GRES      REASON
speed-17             1 pg          drained   32   2:16:1 515490        0      1    gpu16 gpu:6        UGE
speed-05             1 pg            mixed   32   2:16:1 515490        0      1    gpu16 gpu:6       none
speed-[25,27]        2 pg             idle   32   2:16:1 257458        0      1    gpu32 gpu:2       none
\end{verbatim}
\normalsize

%And that there are no more GPUs available on that node (\texttt{hc:gpu=0}).
%Note that no more than two GPUs can be requested for any one job. 

%  2.15.1 P6 on Multi-GPU, Multi-Node
% -------------------
\subsubsection{P6 on Multi-GPU, Multi-Node}

As described earlier, P6 cards are not compatible with \tool{Distribute} and \tool{DataParallel} functions
(\tool{PyTorch}, \tool{Tensorflow}) when running on multiple GPUs.
One workaround is to run the job in Multi-node, single GPU per node
(this applies to P6 nodes: speed-05, speed-17, speed-01):
\begin{verbatim}
  #SBATCH --nodes=2
  #SBATCH --gpus-per-node=1
\end{verbatim}

\noindent An example script for training on multiple nodes with multiple GPUs is provided in 
\href{https://github.com/NAG-DevOps/speed-hpc/blob/master/src/pytorch-multinode-multigpu.sh}{pytorch-multinode-multigpu.sh}
illustrates a job for training on Multi-Nodes, Multi-GPUs

%  2.15.2 CUDA
% -------------------
\subsubsection{CUDA}

When calling \tool{CUDA} within job scripts, it is important to link to the desired
the desired \tool{CUDA} libraries and set the runtime link path to the same libraries. 
For example, to use the \texttt{cuda-11.5} libraries, specify the following in your \texttt{Makefile}.
\begin{verbatim}
  -L/encs/pkg/cuda-11.5/root/lib64 -Wl,-rpath,/encs/pkg/cuda-11.5/root/lib64
\end{verbatim}

\noindent In your job script, specify the version of \texttt{GCC} to use prior to calling CUDA:
\begin{verbatim}
  module load gcc/9.3
\end{verbatim}

%  2.15.3 Special Notes for Sending CUDA Jobs to the GPU Queue
% -------------------
\subsubsection{Special Notes for Sending CUDA Jobs to the GPU Queue}

%It is not possible to create a \texttt{qlogin} session on to a node in the 
%\textbf{GPU Queue} (\texttt{g.q}). As direct logins to these nodes is not 
%available,
Interactive jobs (\xs{sect:interactive-jobs}) must be submitted to the GPU partition to compile and link.
Several versions of CUDA are installed in:
\begin{verbatim}
  /encs/pkg/cuda-11.5/root/
  /encs/pkg/cuda-10.2/root/
  /encs/pkg/cuda-9.2/root
\end{verbatim}

\noindent For CUDA to compile properly for the GPU partition, edit your \texttt{Makefile}
replacing \option{\/usr\/local\/cuda} with one of the above.

%  2.15.4 OpenISS Examples
% -------------------
\subsubsection{OpenISS Examples}
\label{sect:openiss-examples}

These examples represent more comprehensive research-like jobs
for computer vision and other tasks with longer runtime (subject to the number of epochs and other parameters).
They derive from the actual research works of students and their theses and require the use of CUDA and GPUs.
These examples are available as ``native'' jobs on Speed and as Singularity containers.

\noindent Examples include:
\paragraph{OpenISS and REID}
\label{sect:openiss-reid}

A computer-vision-based person re-identification 
(e.g., motion capture-based tracking for stage performance) part of the OpenISS
project by Haotao Lai~\cite{lai-haotao-mcthesis19} using TensorFlow and Keras.
The script is available here:
\href{https://github.com/NAG-DevOps/speed-hpc/blob/master/src/openiss-reid-speed.sh}{openiss-reid-speed.sh}.
The fork of the original repo~\cite{openiss-reid-tfk} adjusted to run on Speed is available here:
\href{https://github.com/NAG-DevOps/openiss-reid-tfk}{openiss-reid-tfk}.
Detailed instructions on how to run it on Speed are in the README:
\url{https://github.com/NAG-DevOps/speed-hpc/tree/master/src#openiss-reid-tfk}

\paragraph{OpenISS and YOLOv3}
\label{sect:openiss-yolov3}

The related code using YOLOv3 framework is in the
the fork of the original repo~\cite{openiss-yolov3} adjusted
to to run on Speed is available here: \href{https://github.com/NAG-DevOps/openiss-yolov3}{openiss-yolov3}.\\

\noindent Example job scripts can run on both CPUs and GPUs, as well as interactively using TensorFlow:

\begin{itemize}
	\item Interactive mode:
  \href{https://github.com/NAG-DevOps/speed-hpc/blob/master/src/openiss-yolo-interactive.sh}
  {openiss-yolo-interactive.sh}
	\item CPU-based job:
  \href{https://github.com/NAG-DevOps/speed-hpc/blob/master/src/openiss-yolo-cpu.sh}
  {openiss-yolo-cpu.sh}
	\item GPU-based job:
  \href{https://github.com/NAG-DevOps/speed-hpc/blob/master/src/openiss-yolo-gpu.sh}
  {openiss-yolo-gpu.sh}
\end{itemize}

\noindent Detailed instructions on how to run these on Speed are in the README: 
\url{https://github.com/NAG-DevOps/speed-hpc/tree/master/src#openiss-yolov3}

% -------------- 2.16 Singularity Containers ------------------
% -------------------------------------------------------------
\subsection{Singularity Containers}
\label{sect:singularity-containers}

Singularity is a container platform designed to execute applications in a portable, 
reproducible, and secure manner. Unlike Docker, Singularity does not require root privileges, 
making it more suitable for HPC environments. If the \tool{/encs} software tree does not have 
the required software available, another option is to run Singularity containers. 
We run EL7 flavor of Linux, and if some projects require Ubuntu or 
other distributions, it is possible to run that software as a container, 
including those converted from Docker. The currently recommended version of Singularity 
is \texttt{singularity/3.10.4/default}.\\

The example
\href{https://github.com/NAG-DevOps/speed-hpc/blob/master/src/lambdal-singularity.sh}{lambdal-singularity.sh}
showcases an immediate use of a container built for the Ubuntu-based LambdaLabs software stack, 
originally built as a Docker image then pulled in as a Singularity container. The source material
used for the docker image was our fork of their official repository: 
\url{https://github.com/NAG-DevOps/lambda-stack-dockerfiles}.\\

\noindent \textbf{Note}: If you make your own containers or pull from DockerHub,
use your \verb+/speed-scratch/$USER+ directory, as these images may easily 
consume gigabytes of space in your home directory, quickly exhausting your quota.\\

\noindent \textbf{Tip}: To check your quota and find big files, 
see: \href{https://www.concordia.ca/ginacody/aits/encs-data-storage.html}{ENCS Data Storage}.\\

We have also built equivalent OpenISS (\xs{sect:openiss-examples}) containers from their Docker 
counterparts for teaching and research purposes~\cite{oi-containers-poster-siggraph2023}. 
The images from \url{https://github.com/NAG-DevOps/openiss-dockerfiles}
and their DockerHub equivalents \url{https://hub.docker.com/u/openiss} can be found in 
\verb+/speed-scratch/nag-public+ with a `\texttt{.sif}' extension.
Some can be run in both batch and interactive modes, covering basics with CUDA, OpenGL rendering, 
and computer vision tasks. Examples include Jupyter notebooks with Conda support.

\begin{verbatim}
  /speed-scratch/nag-public:
  openiss-cuda-conda-jupyter.sif
  openiss-cuda-devicequery.sif
  openiss-opengl-base.sif
  openiss-opengl-cubes.sif
  openiss-opengl-triangle.sif
  openiss-reid.sif
  openiss-xeyes.sif
\end{verbatim}

This section introduces working with Singularity, its containers, and what can and cannot 
be done with Singularity on the ENCS infrastructure. For comprehensive documentation, 
refer to the authors' guide: \url{https://www.sylabs.io/docs/}.\\

%It also assumes that you have successfully installed 
%Singularity on a user-managed/personal system (see next paragraph as to why).

Singularity containers are either built from an existing container, or from scratch. 
Building from scratch requires a recipe file (think of like a Dockerfile) and
must be done with root permissions, which are not available on the ENCS infrastructure. 
Therefore, built-from-scratch containers must be created on a user-managed/personal system. 
There are three types of Singularity containers:
% with one exception (see, Building A Container From An Existing Container).

\begin{itemize}
  \item File-system containers: built around the ext3 file system and are read-write ``file'', but cannot be resized once built.
  \item Sandbox containers: essentially a directory in an existing read-write space and are also read-write.
  \item Squashfs containers: read-only compressed ``file''and are read-only. It is the default build type.
\end{itemize}

\noindent ``A common workflow is to use the ``sandbox'' mode for container development and then build it as a 
default (squashfs) Singularity image when done.'' says the Singularity's authors about builds.
File-system containers are considered legacy and are not commonly used.\\

For many workflows, a Docker container might already exist. In this case, you can use Singularity's 
docker pull function as part of your virtual environment setup in an interactive job allocation:

\small
\begin{verbatim}
  salloc --gpus=1 -n8 --mem=4Gb -t60
  cd /speed-scratch/$USER/
  singularity pull openiss-cuda-devicequery.sif docker://openiss/openiss-cuda-devicequery
  INFO:    Converting OCI blobs to SIF format
  INFO:    Starting build...
\end{verbatim}
\normalsize

\noindent This method can be used for converting Docker containers directly on Speed.
On GPU nodes, make sure to pass on the \option{--nv} flag to Singularity so its containers 
could access the GPUs. See the linked example for more details.
